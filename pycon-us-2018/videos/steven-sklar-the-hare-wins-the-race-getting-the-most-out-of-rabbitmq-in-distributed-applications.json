{
  "copyright_text": "Standard YouTube License",
  "description": "As web apps grow increasingly complex, distributing asynchronous work across multiple background workers is often a basic requirement of a performant app.  While there are a variety of tools that exist to solve this issue, one common feature among them is the need for a robust messaging platform.\n\n[RabbitMQ][1] is a stable, full-featured, and mature solution that is usually found in the Python ecosystem backing [Celery][2] implementations.  While Celery's utilization of RabbitMQ works just fine out of the gate, users with complex workflows, unique constraints, or tight budgets can take advantage of the flexibility of RabbitMQ to streamline their data pipelines and get the most out of their infrastructure.\n\nThis talk will provide an overview of RabbitMQ, review its varied message-routing capabilities, and demonstrate some of the ways in which these features can be utilized in Python applications to solve common yet difficult use-cases.\n\n[1]: https://www.rabbitmq.com/\n[2]: http://www.celeryproject.org/",
  "duration": 1736,
  "language": "eng",
  "recorded": "2018-05-13",
  "related_urls": [
    {
      "label": "Conference schedule",
      "url": "https://us.pycon.org/2018/schedule/talks/"
    },
    {
      "label": "Conference slides (Github)",
      "url": "https://github.com/PyCon/2018-slides"
    },
    {
      "label": "Conference slides (SpeakerDeck)",
      "url": "https://speakerdeck.com/pycon2018"
    },
    "http://www.celeryproject.org/",
    "https://www.rabbitmq.com/"
  ],
  "speakers": [
    "Steven Sklar"
  ],
  "tags": [],
  "thumbnail_url": "https://i.ytimg.com/vi/WXkhJ92-fsY/maxresdefault.jpg",
  "title": "The Hare Wins the Race: Getting the most out of RabbitMQ in distributed applications",
  "videos": [
    {
      "type": "youtube",
      "url": "https://www.youtube.com/watch?v=WXkhJ92-fsY"
    }
  ]
}
